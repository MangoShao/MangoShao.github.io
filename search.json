[{"title":"plan","url":"/2021/04/19/plan/","content":"工作清单：- Steepest Descent在Optimization里详细介绍- 优化器收敛性简介- adaptive类简介- local lipschitz\n\n\n\n202104\n4.21\nmomentum类 \nlc 02 03\n\n\n\n","categories":["Plan"]},{"title":"Optimizers in Machine Learning: Momentum-Type Methods","url":"/2021/04/21/Optimization_in_ML/Momentum-type/","content":"","categories":["Optimization in ML"],"tags":["Optimization | Machine Learning"]},{"title":"Optimizers in Machine Learning: SGD","url":"/2021/04/19/Optimization_in_ML/SGD/","content":"Stochastic Gradient Descent (SGD) 是机器学习与深度学习中最著名也是最基础的优化器，下面介绍SGD的发展：\n优化算法的框架考虑一个无约束优化问题：，目标是寻求最优的使得最小。该问题的一个通用迭代格式如下：其中是步长，是方向。如果满足，便称为下降方向。注意，在不同算法中，不一定是下降方向。\n选择步长的方法很多，最常见的为固定步长和line search；方向的不同选择方式，可以发展出不同的优化算法，如Steepest Descent，Newton Method，Conjugate Gradient Method等。\nSteepest DescentSGD的前身就是优化中最基础的first-order算法：Steepest Descent (最速下降法)。最速下降法的motivation非常简单，选择当前下降最快的方向—负梯度，作为下降方向，其迭代格式如下：但是最速下降法的收敛速度较慢，是次线性收敛，所以在传统优化中很少使用。不过，这不影响SGD在机器学习与深度学习中大放异彩。\n在机器学习与深度学习中，最速下降法被称为Batch Gradient Descent 。\nStochastic Gradient Descent与Batch Gradient Descent相对应的便是Stochastic Gradient Descent，其迭代格式如下：其中是一个样本点。\n以MSE Loss来举例：其中，。SGD的做法便是，对于每一个样本点，都做一次对应的更新：\nSGD实际上给梯度引入了方差，理论上收敛性是次线性收敛，不过收敛速度上不会快于Batch Gradient Descent。不过，有研究认为引入随机梯度使得SGD在能比BGD更好地逃离local minima。\nSGD是每次使用一个样本点去更新，而BGD实际上选择的是全部样本，因此考虑到机器学习与深度学习问题的计算需求，一个折中的mini-batch方式，成为了这些领域的主流优化算法。\nMini-Batch Gradient DescentMini-batch是SGD与BGD的折中选择，每次更新使用一个算力允许范围内较大的batch数据。较于SGD，可以充分利用算力的同时，每次下降得更有效率，减少SGD大方差带来的不稳定性；同时相比于BGD，更好地适应了算力，不会出现算力不足而无法进行计算的尴尬情形。Mini-Batch Gradient Descent的迭代格式如下：\n值得注意的是，机器学习与深度学习中常说的SGD，一般是指Mini-Batch Gradient Descent。\nSGD的缺点SGD主要有两个方面的缺点：\n\n负梯度方向不是一个好的下降方向：使用负梯度下降，一般只能达到次线性收敛；\nscale invariant；\n\n因此，对SGD进行改进也主要分为两大方向：\n\n改进下降方向：\n第一种为Momentum类的方法：Momentum，NAG等；\n第二种便是second-order方法：Newton法，Quasi Newton法(实际上是first-order)等；\n\n\n改进步长：\nAdaptive Methods：AdaGrad，RMSprop，Adam-type等；\nLocal Lipschitz.\n\n\n\n","categories":["Optimizers in ML"],"tags":["Optimization | Machine Learning"]},{"title":"LeetCode 01 Solution","url":"/2021/04/20/LeetCode/01/","content":"法一：暴力class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        lens = len(nums)        for i in range(lens):            j = i + 1            while j &lt; lens:                if nums[i] + nums[j] == target:                    return [i, j]                else:                    j += 1        return None\n\n\n空间：\n时间：\n\n法二：哈希表class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashtab = {}        for idx, num in enumerate(nums):            other_num = target - num            if other_num in hashtab:                return [hashtab[other_num], idx]            hashtab[num] = idx        return None\n\n\n空间：\n时间：\n\n","categories":["LeetCode"],"tags":["TwoSum | Hashtable"]},{"title":"LeetCode 02 Solution","url":"/2021/04/20/LeetCode/02/","content":"Solution 1\n新建一个dummyhead，记录head；初始化进位变量；\n每次新建一个链表节点，计算，节点值为；\n维护变量， ；l1，l2指向下个节点(如果存在)；\n遍历完两个链表，考虑最高位是否为；\n返回dummyhead.next.\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        head = ListNode(0)        tmp = head        add = 0                while l1 or l2:            a = l1.val if l1 else 0            b = l2.val if l2 else 0            val = a + b + add            add = val // 10            tmp.next = ListNode(val % 10)            tmp = tmp.next            if l1: l1 = l1.next            if l2: l2 = l2.next                if add != 0: tmp.next = ListNode(add)        return head.next\n\n\n空间：；\n时间：.\n\nSolution 2对Solution 1空间上的改进：\n\n直接使用l1或者l2来作为输出，如果该链表为较短的一方，则指向另一方的剩余部分。\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        head = ListNode(0)        tmp = head        tmp.next = l1        add = 0        other = l2        while tmp.next:            tmp = tmp.next            if other:                val = tmp.val + other.val + add            else:                val = tmp.val + add            add = val // 10            tmp.val = val % 10            if other: other = other.next            if not tmp.next:                 tmp.next = other                other = None        if add != 0: tmp.next = ListNode(add)        return head.next\n\n\n空间：；\n时间：.\n\nSolution 3递归，将Solution 1写成递归形式：\n\n终止条件：not l1 and not l2 and add == 0；\n每次迭代：新建head.next节点，计算节点值，维护add；\n下一步：head，l1，l2指向下个节点。\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:                def recur(l1, l2, head, add):            if not l1 and not l2 and add == 0: return None            val = l1.val if l1 else 0            val += l2.val if l2 else 0             val += add            head.next = ListNode(val % 10)            add = val // 10            recur(l1.next if l1 else None, l2.next if l2 else None, head.next, add)                head = ListNode(0)        tmp = head        add = 0        recur(l1, l2, tmp, add)        return head.next\n\n\n空间： （不确定）；\n时间：.\n\n","categories":["LeetCode"],"tags":["Linkedlist | Dummyhead | TwoSum"]},{"title":"LeetCode 03 Solution","url":"/2021/04/21/LeetCode/03/","content":"","categories":["LeetCode"]}]