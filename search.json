[{"title":"plan","url":"/2021/04/19/plan/","content":"工作清单：- Steepest Descent在Optimization里详细介绍- 优化器收敛性简介- adaptive类简介- local lipschitz\n\n\n\n202104\n4.21\nmomentum类 \nlc 02 03\n\n\n\n","categories":["Plan"]},{"title":"LeetCode 01 Solution","url":"/2021/04/20/LeetCode/01/","content":"法一：暴力class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        lens = len(nums)        for i in range(lens):            j = i + 1            while j &lt; lens:                if nums[i] + nums[j] == target:                    return [i, j]                else:                    j += 1        return None\n\n\n空间：\n时间：\n\n法二：哈希表class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashtab = {}        for idx, num in enumerate(nums):            other_num = target - num            if other_num in hashtab:                return [hashtab[other_num], idx]            hashtab[num] = idx        return None\n\n\n空间：\n时间：\n\n","categories":["LeetCode"],"tags":["TwoSum | Hashtable"]},{"title":"LeetCode 03 Solution","url":"/2021/04/21/LeetCode/03/","content":"Solution 1滑动窗口结合Hashtable：\n\n左指针记录左起点；\nHashtable记录当前字串；\n遇到重复，left前移，依次去除Hashtable的item，直到left为被重复项的下一项；遇到非重复，长度加1，并将其加入Hashtable\nres记录最大长度。\n\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        hashtab = set()        n = len(s)        length = 0        res = 0        left = 0        for i in range(n):            if s[i] in hashtab:                 while s[i] in hashtab:                    hashtab.remove(s[left])                    left += 1                    length -= 1            hashtab.add(s[i])            length += 1            res = max(res, length)        return res\n\n\n空间：；\n时间：，因为最多做次删除。\n\nSolution 2对solution 1的优化：\n\n主要针对每次去除操作，该操作是多余的；\n可以用heap先建一个字符表，不过在python里这是不方便的；\n\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        heap = {}        n = len(s)        res = 0        left = 0        for i in range(n):            if s[i] in heap and heap[s[i]] &gt;= left:                left = heap[s[i]] + 1            heap[s[i]] = i            res = max(res, i - left + 1)        return res\n\n\n空间：\n时间：.\n\n","categories":["LeetCode"],"tags":["Sliding window | Hashtable | Heap"]},{"title":"LeetCode 02 Solution","url":"/2021/04/20/LeetCode/02/","content":"Solution 1\n新建一个dummyhead，记录head；初始化进位变量；\n每次新建一个链表节点，计算，节点值为；\n维护变量， ；l1，l2指向下个节点(如果存在)；\n遍历完两个链表，考虑最高位是否为；\n返回dummyhead.next.\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        head = ListNode(0)        tmp = head        add = 0                while l1 or l2:            a = l1.val if l1 else 0            b = l2.val if l2 else 0            val = a + b + add            add = val // 10            tmp.next = ListNode(val % 10)            tmp = tmp.next            if l1: l1 = l1.next            if l2: l2 = l2.next                if add != 0: tmp.next = ListNode(add)        return head.next\n\n\n空间：；\n时间：.\n\nSolution 2对Solution 1空间上的改进：\n\n直接使用l1或者l2来作为输出，如果该链表为较短的一方，则指向另一方的剩余部分。\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        head = ListNode(0)        tmp = head        tmp.next = l1        add = 0        other = l2        while tmp.next:            tmp = tmp.next            if other:                val = tmp.val + other.val + add            else:                val = tmp.val + add            add = val // 10            tmp.val = val % 10            if other: other = other.next            if not tmp.next:                 tmp.next = other                other = None        if add != 0: tmp.next = ListNode(add)        return head.next\n\n\n空间：；\n时间：.\n\nSolution 3递归，将Solution 1写成递归形式：\n\n终止条件：not l1 and not l2 and add == 0；\n每次迭代：新建head.next节点，计算节点值，维护add；\n下一步：head，l1，l2指向下个节点。\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:                def recur(l1, l2, head, add):            if not l1 and not l2 and add == 0: return None            val = l1.val if l1 else 0            val += l2.val if l2 else 0             val += add            head.next = ListNode(val % 10)            add = val // 10            recur(l1.next if l1 else None, l2.next if l2 else None, head.next, add)                head = ListNode(0)        tmp = head        add = 0        recur(l1, l2, tmp, add)        return head.next\n\n\n空间： （不确定）；\n时间：.\n\n","categories":["LeetCode"],"tags":["Linkedlist | Dummyhead | TwoSum"]},{"title":"LeetCode 897 Solution","url":"/2021/04/26/LeetCode/897/","content":"Solution 1新Tree非递归# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def increasingBST(self, root: TreeNode) -&gt; TreeNode:        s = []        res = TreeNode(0)        tmp = res        while root or s:            while root:                s.append(root)                root = root.left            if s:                root = s.pop()                tmp.right = TreeNode(root.val)                tmp = tmp.right                root = root.right        return res.right\n\n\n空间：；\n时间：.\n\n递归# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def increasingBST(self, root: TreeNode) -&gt; TreeNode:        def recur(root, tmp):            if not root: return tmp            tmp = recur(root.left, tmp)            tmp.right = TreeNode(root.val)            tmp = tmp.right            tmp = recur(root.right, tmp)            return tmp              res = TreeNode(0)        tmp = res        recur(root, tmp)        return res.right\n\n\n空间：；\n时间：.\n\n修改Tree非递归# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def increasingBST(self, root: TreeNode) -&gt; TreeNode:        s = []        res = TreeNode(0)        tmp = res        while root or s:            while root:                s.append(root)                root = root.left            if s:                root = s.pop()                tmp.right = root                root.left = None                tmp = tmp.right                root = root.right        return res.right\n\n\n空间：；\n时间：.\n\n递归# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def increasingBST(self, root: TreeNode) -&gt; TreeNode:        def recur(root, tmp):            if not root: return tmp            tmp = recur(root.left, tmp)            root.left = None            tmp.right = root            tmp = tmp.right            tmp = recur(root.right, tmp)            return tmp              res = TreeNode(0)        tmp = res        recur(root, tmp)        return res.right\n\n\n空间：(存疑)；\n时间：.\n\nSolution 2\n新传一个tail记录上一个节点。\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def increasingBST(self, root: TreeNode, tail= None) -&gt; TreeNode:        if not root: return tail        res = self.increasingBST(root.left, root)        root.left = None        root.right = self.increasingBST(root.right, tail)        return res\n\n\n空间：；\n时间：.\n\n","categories":["LeetCode"],"tags":["InOrder | BinaryTree | Recursive"]},{"title":"Optimizers in Machine Learning: Momentum-Type Methods","url":"/2021/04/21/Optimization_in_ML/Momentum-type/","content":"","categories":["Optimizers in ML"],"tags":["Optimization | Machine Learning"]},{"title":"Optimizers in Machine Learning: SGD","url":"/2021/04/19/Optimization_in_ML/SGD/","content":"Stochastic Gradient Descent (SGD) 是机器学习与深度学习中最著名也是最基础的优化器，下面介绍SGD的发展：\n优化算法的框架考虑一个无约束优化问题：，目标是寻求最优的使得最小。该问题的一个通用迭代格式如下：其中是步长，是方向。如果满足，便称为下降方向。注意，在不同算法中，不一定是下降方向。\n选择步长的方法很多，最常见的为固定步长和line search；方向的不同选择方式，可以发展出不同的优化算法，如Steepest Descent，Newton Method，Conjugate Gradient Method等。\nSteepest DescentSGD的前身就是优化中最基础的first-order算法：Steepest Descent (最速下降法)。最速下降法的motivation非常简单，选择当前下降最快的方向—负梯度，作为下降方向，其迭代格式如下：但是最速下降法的收敛速度较慢，是次线性收敛，所以在传统优化中很少使用。不过，这不影响SGD在机器学习与深度学习中大放异彩。\n在机器学习与深度学习中，最速下降法被称为Batch Gradient Descent 。\nStochastic Gradient Descent与Batch Gradient Descent相对应的便是Stochastic Gradient Descent，其迭代格式如下：其中是一个样本点。\n以MSE Loss来举例：其中，。SGD的做法便是，对于每一个样本点，都做一次对应的更新：\nSGD实际上给梯度引入了方差，理论上收敛性是次线性收敛，不过收敛速度上不会快于Batch Gradient Descent。不过，有研究认为引入随机梯度使得SGD在能比BGD更好地逃离local minima。\nSGD是每次使用一个样本点去更新，而BGD实际上选择的是全部样本，因此考虑到机器学习与深度学习问题的计算需求，一个折中的mini-batch方式，成为了这些领域的主流优化算法。\nMini-Batch Gradient DescentMini-batch是SGD与BGD的折中选择，每次更新使用一个算力允许范围内较大的batch数据。较于SGD，可以充分利用算力的同时，每次下降得更有效率，减少SGD大方差带来的不稳定性；同时相比于BGD，更好地适应了算力，不会出现算力不足而无法进行计算的尴尬情形。Mini-Batch Gradient Descent的迭代格式如下：\n值得注意的是，机器学习与深度学习中常说的SGD，一般是指Mini-Batch Gradient Descent。\nSGD的缺点SGD主要有两个方面的缺点：\n\n负梯度方向不是一个好的下降方向：使用负梯度下降，一般只能达到次线性收敛；\nscale invariant；\n\n因此，对SGD进行改进也主要分为两大方向：\n\n改进下降方向：\n第一种为Momentum类的方法：Momentum，NAG等；\n第二种便是second-order方法：Newton法，Quasi Newton法(实际上是first-order)等；\n\n\n改进步长：\nAdaptive Methods：AdaGrad，RMSprop，Adam-type等；\nLocal Lipschitz.\n\n\n\n","categories":["Optimizers in ML"],"tags":["Optimization | Machine Learning"]}]